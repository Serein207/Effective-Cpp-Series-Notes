# 条款13：以对象管理资源

假设我们使用一个用来建模投资行为（例如股票、债券）的程序，其中各式各样的投资类型继承自一个class Investment：

```cpp
class Investment{...};  // root class
```

这个程序库通过一个工厂函数供应我们特定的Investment对象：

```cpp
Investment* createInvestment();
```

createInvestment的调用者使用了函数返回的对象后，有责任删除它。现在考虑有个f函数履行了这个责任：

```cpp
void f() {
  Investment* pInv = createInvestment();
  ...
  delete pInv;
}
```

这看起来很好，但很多情况下f可能无法删除它来自createInvestment的投资对象。如提前return，循环语句退出，或是抛出异常。无论delete如何被忽略，都会造成资源泄露。

为确保createInvestment返回的资源总是被释放，我们需要将资源放进对象内，当控制流离开f，该对象的析构函数会自动释放那些资源。把资源放进对象内，我们便可依靠C++的析构函数自动调用机制确保资源被释放。

以对象管理资源的两个关键想法是：

- **获得资源后立刻放进管理对象内。** “以对象管理资源”的观念常被成为“资源取得时机便是初始化时机（RAII）”。我们几乎总是在获得一笔资源后于同一语句内以他初始化某个管理对象。有时获得的资源会被拿来赋值某个管理对象。
- **管理对象运用析构函数确保资源被释放。** 不论控制流如何离开区块，一旦对象被销毁，其洗过函数自然会被自动调用，于是资源被释放。

> 书中示例代码使用已经被弃用的 `std::auto_ptr` ，故本文没有更多示例。

本条款也建议，如果你打算手动释放资源，容易发生某些错误。封装好的资源管理类如智能指针往往比较能够轻松遵循本条款，但有时你所使用的资源是这些class无法妥善管理的，你需要自己设计资源管理类。

> **请记住**
>
> - 为防止资源泄露，请使用RAII对象，它们在构造函数中获得资源并在析构函数中释放资源。